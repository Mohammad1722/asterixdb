<!--
 ! Licensed to the Apache Software Foundation (ASF) under one
 ! or more contributor license agreements.  See the NOTICE file
 ! distributed with this work for additional information
 ! regarding copyright ownership.  The ASF licenses this file
 ! to you under the Apache License, Version 2.0 (the
 ! "License"); you may not use this file except in compliance
 ! with the License.  You may obtain a copy of the License at
 !
 !   http://www.apache.org/licenses/LICENSE-2.0
 !
 ! Unless required by applicable law or agreed to in writing,
 ! software distributed under the License is distributed on an
 ! "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 ! KIND, either express or implied.  See the License for the
 ! specific language governing permissions and limitations
 ! under the License.
 !-->

# GIS Performance Tuning #
## <a id="toc">Table of Contents</a> ##

* [Introduction](#introduction)
* [R-Tree Index](#rtree)
* [Spatial Joins](#spatial_joins)

## <a id="introduction">Introduction</a>


## <a id="rtree">R-Tree Index</a>
AsterixDB uses R-Tree based spatial indexes to speed up queries on spatial functions like filtering a list of spatial objects and spatial join queries.
The basic idea behind an R-Tree is to group nearby objects and represent them in the next higher level of the tree with their Minimum Bounding Rectangle (MBR). Because all objects are contained within this bounding rectangle, a query that does not intersect the bounding rectangle will not intersect any of the contained objects. This can also be interpreted as an increasingly coarse approximation of the data set.  
The bounding rectangles are used to decide whether or not to search inside a subtree. In this way, most of the nodes in the tree are never read during a search. You can find more information about R-Trees [here](https://dl.acm.org/doi/pdf/10.1145/602259.602266).

### Creating/Deleting Indexes

The general query to **create** a spatial index is:
```SQL
CREATE INDEX IndexName ON DatasetName(GeometryFieldName) TYPE RTREE;
```
This query uses the specified field in the dataset to create an R-Tree based index that can be used to improve the spatial queries performance as explained in the previous section.

The general query to **delete** a spatial index is:
```SQL
DROP INDEX DatasetName.IndexName IF EXISTS;
```
To illustrate the use of indexes let's assume we have the following dataset:
```SQL
CREATE TYPE ZipCodeBoundariesType AS {
  id: uuid,
  g: geometry
};
CREATE DATASET ZipCodeBoundaries(ZipCodeBoundariesType) PRIMARY KEY id AUTOGENERATED;
```
Then, in order to create a spatial index for this dataset we can run the following query.
```SQL
CREATE INDEX ZipCodeIdx ON ZipCodeBoundaries(g) TYPE RTREE;
```
Finally, to delete the index we can use use this query:
```SQL
DROP INDEX ZipCodeBoundaries.ZipCodeIdx IF EXISTS;
```

### Queries improved by indexes

By default, AsterixDB uses nested-loop joins for join queries with spatial data except for the [spatial join functions](#spatial_joins). However, if a spatial index is available for the field, an indexed nested-loop join is always used no matter which function is used.

For example, using the indexed dataset above, all of the following queries will use indexed nested-loop joins:  

In which Zip Code boundary does this point exist?
```SQL
SELECT uuid
FROM ZipCodeBoundaries
WHERE st_contains(g, st_make_point(180, 154));
```
What are the Zip Code boundaries crossed by this line?
```SQL
SELECT uuid
FROM ZipCodeBoundaries
WHERE st_crosses(g, st_geom_from_geojson({"type":"LineString","coordinates":[[-89.34, -12.6],[-90.1,-12.56]]}));
```
What are the neighbours of each Zip Code?
```SQL
SELECT z1.uuid, z2.uuid
FROM ZipCodeBoundaries z1 JOIN ZipCodeBoundaries z2 ON st_touches(z1.g, z2.g);
```

## <a id="spatial_joins">Spatial Joins</a>

AsterixDB supports efficient spatial join query performance.
In particular, it will execute the [Partition Based Spatial-Merge Join](http://pages.cs.wisc.edu/~dewitt/includes/paradise/spjoin.pdf) (PBSM) algorithm for the join queries with a spatial function in join condition. These functions are:  
* [`spatial_intersect(ARectangle, ARectangle)`](./geo/functions.html#predicate).
* ESRI's spatial functions:  
    * [`st_intersects`](./geo/functions.html#predicate), 
    * [`st_overlaps`](./geo/functions.html#predicate), 
    * [`st_touches`](./geo/functions.html#predicate), 
    * [`st_contains`](./geo/functions.html#predicate), 
    * [`st_crosses`](./geo/functions.html#predicate), 
    * [`st_within`](./geo/functions.html#predicate), 
    * [`st_distance`](./geo/functions.html#predicate).

The PBSM join is done in two steps:  
* Filter step:  
This step uses an approximation of each spatial object, that is its Minimum Bounding Rectangle (MBR), to eliminate tuples that cannot be part of the result.
* Refinement step:  
This step examines each remaining candidate to check if the join predicate is satisfied.

For the filter step, the algorithm iterates over both sets of objects, calculating the MBR for each object and mapping it to the uniform grid. The mapping process locates grid cells that intersect with the MBR volume and creates a pointer to the MBR from each intersecting grid cell.
Because one MBR can map to multiple grid cells. We use a hashmap to store this many-many relationship between the MBR and the grid cell. It maps a list of pointers to a grid cell identifier. To map an MBR, we look up the list of pointers for each intersecting grid cell and insert the pointer into that list. The hashmap, in addition to providing a fast access mechanism to the list of pointers, also helps to reduce the memory footprint because only grid cells containing one or more pointers to an MBR require an entry in the hashmap and no memory is wasted in storing empty grid cells.

### Grid Resolution

Changing the grid resolution has a direct impact on the algorithm's performance. As the resolution increases, an MBR is more likely to be mapped to a large number of grid cells, increasing the memory footprint. This also reduces performance because more comparisons must be performed during the refinement step. Because MBRs mapped to multiple cells must be compared multiple times, the number of comparisons increases.

Decreasing the resolution, on the other hand, causes each grid cell to contain many MBRs, lowering performance because all MBRs in the same grid cell must be compared pairwise, increasing the number of comparisons. However, a small resolution reduces the algorithm's memory consumption because an MBR is less likely to be mapped to a large number of grid cells. Furthermore, the likelihood of comparing the same pair of MBRs multiple times because they are assigned to multiple cells (as is the case with fine resolution) is significantly reduced, reducing the overall number of comparisons. 

Both extremes have advantages and disadvantages and it is difficult to set the resolution intuitively. AsterixDB will, by default, compute the MBR at run-time and set the grid size to 100x100. However, users can also set other values for these parameters using [spatial partitioning hint](#spatial_partitioning_hint).

### <a id="spatial_partitioning_hint">Spatial Partitioning Hint</a>

For the spatial partitioning, PBSM algorithm requires the following information to partition data into a grid:  
- The MBR of two input datasets. (default: calculated at run-time)
- The grid resolution. (default: 100x100)

Usually the values set by AsterixDB are efficient but users can change these parameters using a *spatial partitioning hint*. The general format for the spatial partitioning hint is as follows:
```SQL
/*+ spatial-partitioning(x1, y1, x2, y2, num_rows, num_cols) */
```
Where:
* (x1, y1) and (x2, y2) ar the top-left and bottom right vertices of the MBR of the input datasets.
* num_rows and num_cols are the number of rows and number of columns of the grid, respectively. Resulting in a grid size of num_rows Ã— num_cols.

As an example, assuming we want to set the MBR of two input datasets is (-180.0, -83.0, 180.0, 90.0) and use a grid size of 10x10. The spatial partitioning hint becomes:
```SQL
/*+ spatial-partitioning(-180.0, -83.0, 180.0, 90.0, 10, 10) */
```
And can be used in queries like this:
```SQL
DROP DATAVERSE test IF EXISTS;
CREATE DATAVERSE test;
USE test;

-- Make GeomType
CREATE TYPE GeomType AS closed {
    id: int32,
    geom: rectangle
};

-- Make Park dataset
CREATE DATASET ParkSet (GeomType) primary key id;

-- Make Lake dataset
CREATE DATASET LakeSet (GeomType) primary key id;

SELECT COUNT(*) FROM ParkSet AS ps, LakeSet AS ls
WHERE /*+ spatial-partitioning(-180.0, -83.0, 180.0, 90.0, 10, 10) */ spatial_intersect(ps.geom, ls.geom);
```


